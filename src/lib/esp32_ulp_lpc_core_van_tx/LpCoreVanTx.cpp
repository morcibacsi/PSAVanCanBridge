#include <ulp_lp_core.h>
#include <string.h>

#include "LpCoreVanTx.hpp"
#include "ulp_main.h" // This is the header file generated by the ULP compiler and it's name comes from the CMakeLists.txt in the ulp/main folder

#define STUFFED_VAL(byte) (((byte) & 0xF0) << 2) | ((~(byte) & 0x10) << 1) | (((byte) & 0x0F) << 1) | ((~(byte) & 0x01) << 0)
#define SPLIT_VAN_IDENTIFIER(iden, byte1, byte2) (*(byte1) = (uint8_t)(((iden) << 4 & 0xff00) >> 8), *(byte2) = (uint8_t)((iden) & 0xF))
#define VAN_FRAME_SOF 0x0E

extern const uint8_t ulp_main_bin_start[] asm("_binary_ulp_main_bin_start");
extern const uint8_t ulp_main_bin_end[]   asm("_binary_ulp_main_bin_end");

uint16_t LpCoreVanTx::Crc15(const uint8_t data[], const uint8_t length)
{
    const uint8_t order = 15;
    const uint16_t polynom = 0xF9D;
    const uint16_t xorValue = 0x7FFF;
    const uint16_t mask = 0x7FFF;

    uint16_t crc = 0x7FFF;

    for (uint8_t i = 0; i < length; i++)
    {
        uint8_t currentByte = data[i];

        // rotate one data byte including crcmask
        for (uint8_t j = 0; j < 8; j++)
        {
            bool bit = (crc & (1 << (order - 1))) != 0;
            if ((currentByte & 0x80) != 0)
            {
                bit = !bit;
            }
            currentByte <<= 1;

            crc = ((crc << 1) & mask) ^ (-bit & polynom);
        }
    }

    // perform xor and multiply result by 2 to turn 15 bit result into 16 bit representation
    return (crc ^ xorValue) << 1;
}

void LpCoreVanTx::InternalSendFrame(const uint8_t retryCount, const uint8_t data[], const uint8_t length)
{
    uint32_t *ptr = (uint32_t *)&ulp_VAN_DATA;
    //ptr[0] = STUFFED_VAL(0x0E);

    uint8_t i = 0;

    while (i < length)
    {
        if (i == length - 1)
        {
            // the second byte of the CRC contains the EOD - a pair of zeros which commit an E-Manchester violation marking the end of transmitted data.
            ptr[i] = ((STUFFED_VAL(data[i])) & ((STUFFED_VAL(data[i]))-1));
        }
        else
        {
            ptr[i] = (STUFFED_VAL(data[i]));
        }
        i++;
    }
    // EOF
    //ptr[1 + i] = 0x3FF;

    //ulp_VAN_DATA_LENGTH = length + 1;
    ulp_VAN_RETRY_COUNT = retryCount;
    ulp_VAN_DATA_LENGTH = length + 0;
    ulp_VAN_TX_FINISHED = 0;
    ulp_VAN_START_TX = 1;
}

LpCoreVanTx::LpCoreVanTx(gpio_num_t rxPin, gpio_num_t txPin, LP_VAN_NETWORK_SPEED networkSpeed)
{
    _rxPin = rxPin;
    _txPin = txPin;
    _networkSpeed = networkSpeed;

    esp_err_t err = rtc_gpio_init(_txPin);
    ESP_ERROR_CHECK(err);

    err = rtc_gpio_set_direction(_txPin, RTC_GPIO_MODE_OUTPUT_ONLY);
    ESP_ERROR_CHECK(err);

    rtc_gpio_init(_rxPin);
    rtc_gpio_set_direction(_rxPin, RTC_GPIO_MODE_INPUT_ONLY);
    rtc_gpio_pulldown_dis(_rxPin);
    rtc_gpio_pullup_dis(_rxPin);
}

void LpCoreVanTx::Start()
{
    esp_err_t err = ulp_lp_core_load_binary(ulp_main_bin_start, (ulp_main_bin_end - ulp_main_bin_start));
    ESP_ERROR_CHECK(err);

    /* Start the ULP program */
    ulp_lp_core_cfg_t cfg = {
        .wakeup_source = ULP_LP_CORE_WAKEUP_SOURCE_HP_CPU
    };

    err = ulp_lp_core_run(&cfg);
    ESP_ERROR_CHECK(err);

    ulp_SET_VAN_RX_PIN = _rxPin;
    ulp_SET_VAN_TX_PIN = _txPin;
    ulp_VAN_START_APP = 1;
}

void LpCoreVanTx::SendNormalFrame(const uint16_t identifier, const uint8_t data[], const uint8_t length, const bool requireAck)
{
    // van frame length is length of data + 5 bytes (SOF, ID, COM, CRC, CRC)
    uint8_t vanFrame[length + 5] = {  };

    uint8_t idenByte1, idenByte2;
    SPLIT_VAN_IDENTIFIER(identifier, &idenByte1, &idenByte2);

    // COM
    idenByte2 = idenByte2 << 4 | 0x08;

    if (requireAck)
        idenByte2 = idenByte2 | 0x04;

    // SOF
    vanFrame[0] = VAN_FRAME_SOF;

    // ID & COM
    vanFrame[1] = idenByte1;
    vanFrame[2] = idenByte2;

    // Data
    memcpy(&vanFrame[3], data, length);

    // CRC - exclude SOF
    uint16_t crc = Crc15(&vanFrame[1], length + 2);
    vanFrame[length + 3] = (crc >> 8) & 0xFF;
    vanFrame[length + 4] = (crc & 0xFF);

    ulp_VAN_FRAME_TYPE = 0; // VAN_FRAME_TYPE_NORMAL

    InternalSendFrame(1, vanFrame, length + 5);
}

void LpCoreVanTx::SendReplyRequestFrame(const uint16_t identifier)
{
    // van frame length is length of data + 5 bytes (SOF, ID, COM, CRC, CRC)
    uint8_t vanFrame[5] = { 0 };

    uint8_t idenByte1, idenByte2;
    SPLIT_VAN_IDENTIFIER(identifier, &idenByte1, &idenByte2);
    idenByte2 = idenByte2 << 4 | 0x0F;

    // SOF
    vanFrame[0] = VAN_FRAME_SOF;

    // ID & COM
    vanFrame[1] = idenByte1;
    vanFrame[2] = idenByte2;

    // CRC - exclude SOF
    uint16_t crc = Crc15(&vanFrame[1], 2);
    vanFrame[3] = (crc >> 8) & 0xFF;
    vanFrame[4] = (crc & 0xFF);

    ulp_VAN_FRAME_TYPE = 1; // VAN_FRAME_TYPE_QUERY

    InternalSendFrame(1, vanFrame, 5);
}

bool LpCoreVanTx::IsTxPossible()
{
    return ulp_VAN_TX_FINISHED == 1;
}
